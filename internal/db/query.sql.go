// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTask = `-- name: CreateTask :one
INSERT INTO tasks (
    id, model_id, input_path, signature, status, scheduled_at, error_log, mem_lim, cpu_lim, gpu_enable
) VALUES (
    $1, $2, $3, $4, COALESCE(NULLIF($5::task_status, ''), 'initializing'), $6, $7, $8, $9, $10
)
RETURNING id, model_id, input_path, result_path, signature, status, container_id, error_log, scheduled_at, started_at, finished_at, created_at, updated_at, mem_lim, cpu_lim, gpu_enable
`

type CreateTaskParams struct {
	ID          pgtype.UUID
	ModelID     string
	InputPath   string
	Signature   string
	Column5     TaskStatus
	ScheduledAt pgtype.Timestamptz
	ErrorLog    pgtype.Text
	MemLim      pgtype.Int4
	CpuLim      pgtype.Int4
	GpuEnable   pgtype.Bool
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (Task, error) {
	row := q.db.QueryRow(ctx, createTask,
		arg.ID,
		arg.ModelID,
		arg.InputPath,
		arg.Signature,
		arg.Column5,
		arg.ScheduledAt,
		arg.ErrorLog,
		arg.MemLim,
		arg.CpuLim,
		arg.GpuEnable,
	)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.ModelID,
		&i.InputPath,
		&i.ResultPath,
		&i.Signature,
		&i.Status,
		&i.ContainerID,
		&i.ErrorLog,
		&i.ScheduledAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MemLim,
		&i.CpuLim,
		&i.GpuEnable,
	)
	return i, err
}

const findCachedTask = `-- name: FindCachedTask :one
SELECT result_path FROM tasks
WHERE signature = $1 AND status = 'completed'
LIMIT 1
`

func (q *Queries) FindCachedTask(ctx context.Context, signature string) (pgtype.Text, error) {
	row := q.db.QueryRow(ctx, findCachedTask, signature)
	var result_path pgtype.Text
	err := row.Scan(&result_path)
	return result_path, err
}

const getNextQueuedTask = `-- name: GetNextQueuedTask :one
SELECT id, model_id, input_path, signature, scheduled_at, mem_lim, cpu_lim, gpu_enable 
FROM tasks
WHERE status = 'queued' 
  AND (scheduled_at IS NULL OR scheduled_at <= NOW())
ORDER BY scheduled_at ASC
LIMIT 1
FOR UPDATE SKIP LOCKED
`

type GetNextQueuedTaskRow struct {
	ID          pgtype.UUID
	ModelID     string
	InputPath   string
	Signature   string
	ScheduledAt pgtype.Timestamptz
	MemLim      pgtype.Int4
	CpuLim      pgtype.Int4
	GpuEnable   pgtype.Bool
}

func (q *Queries) GetNextQueuedTask(ctx context.Context) (GetNextQueuedTaskRow, error) {
	row := q.db.QueryRow(ctx, getNextQueuedTask)
	var i GetNextQueuedTaskRow
	err := row.Scan(
		&i.ID,
		&i.ModelID,
		&i.InputPath,
		&i.Signature,
		&i.ScheduledAt,
		&i.MemLim,
		&i.CpuLim,
		&i.GpuEnable,
	)
	return i, err
}

const getRunningTasksContainers = `-- name: GetRunningTasksContainers :many
SELECT id, container_id FROM tasks
WHERE status = 'running' AND container_id IS NOT NULL
`

type GetRunningTasksContainersRow struct {
	ID          pgtype.UUID
	ContainerID pgtype.Text
}

func (q *Queries) GetRunningTasksContainers(ctx context.Context) ([]GetRunningTasksContainersRow, error) {
	rows, err := q.db.Query(ctx, getRunningTasksContainers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRunningTasksContainersRow
	for rows.Next() {
		var i GetRunningTasksContainersRow
		if err := rows.Scan(&i.ID, &i.ContainerID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskByID = `-- name: GetTaskByID :one
SELECT id, model_id, input_path, result_path, signature, status, container_id, error_log, scheduled_at, started_at, finished_at, created_at, updated_at, mem_lim, cpu_lim, gpu_enable FROM tasks
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTaskByID(ctx context.Context, id pgtype.UUID) (Task, error) {
	row := q.db.QueryRow(ctx, getTaskByID, id)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.ModelID,
		&i.InputPath,
		&i.ResultPath,
		&i.Signature,
		&i.Status,
		&i.ContainerID,
		&i.ErrorLog,
		&i.ScheduledAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MemLim,
		&i.CpuLim,
		&i.GpuEnable,
	)
	return i, err
}

const markTaskCompleted = `-- name: MarkTaskCompleted :one
UPDATE tasks
SET 
    status = 'completed',
    result_path = $2,
    finished_at = NOW(),
    updated_at = NOW()
WHERE id = $1
RETURNING id, model_id, input_path, result_path, signature, status, container_id, error_log, scheduled_at, started_at, finished_at, created_at, updated_at, mem_lim, cpu_lim, gpu_enable
`

type MarkTaskCompletedParams struct {
	ID         pgtype.UUID
	ResultPath pgtype.Text
}

func (q *Queries) MarkTaskCompleted(ctx context.Context, arg MarkTaskCompletedParams) (Task, error) {
	row := q.db.QueryRow(ctx, markTaskCompleted, arg.ID, arg.ResultPath)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.ModelID,
		&i.InputPath,
		&i.ResultPath,
		&i.Signature,
		&i.Status,
		&i.ContainerID,
		&i.ErrorLog,
		&i.ScheduledAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MemLim,
		&i.CpuLim,
		&i.GpuEnable,
	)
	return i, err
}

const markTaskFailed = `-- name: MarkTaskFailed :one
UPDATE tasks
SET 
    status = 'failed',
    error_log = $2,
    finished_at = NOW(),
    updated_at = NOW()
WHERE id = $1
RETURNING id, model_id, input_path, result_path, signature, status, container_id, error_log, scheduled_at, started_at, finished_at, created_at, updated_at, mem_lim, cpu_lim, gpu_enable
`

type MarkTaskFailedParams struct {
	ID       pgtype.UUID
	ErrorLog pgtype.Text
}

func (q *Queries) MarkTaskFailed(ctx context.Context, arg MarkTaskFailedParams) (Task, error) {
	row := q.db.QueryRow(ctx, markTaskFailed, arg.ID, arg.ErrorLog)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.ModelID,
		&i.InputPath,
		&i.ResultPath,
		&i.Signature,
		&i.Status,
		&i.ContainerID,
		&i.ErrorLog,
		&i.ScheduledAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MemLim,
		&i.CpuLim,
		&i.GpuEnable,
	)
	return i, err
}

const markTaskRunning = `-- name: MarkTaskRunning :one
UPDATE tasks
SET 
    status = 'running',
    container_id = $2,
    started_at = NOW(),
    updated_at = NOW()
WHERE id = $1
RETURNING id, model_id, input_path, result_path, signature, status, container_id, error_log, scheduled_at, started_at, finished_at, created_at, updated_at, mem_lim, cpu_lim, gpu_enable
`

type MarkTaskRunningParams struct {
	ID          pgtype.UUID
	ContainerID pgtype.Text
}

func (q *Queries) MarkTaskRunning(ctx context.Context, arg MarkTaskRunningParams) (Task, error) {
	row := q.db.QueryRow(ctx, markTaskRunning, arg.ID, arg.ContainerID)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.ModelID,
		&i.InputPath,
		&i.ResultPath,
		&i.Signature,
		&i.Status,
		&i.ContainerID,
		&i.ErrorLog,
		&i.ScheduledAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MemLim,
		&i.CpuLim,
		&i.GpuEnable,
	)
	return i, err
}
